# Программа для оптимизации исполнения орбитального маневра
Сейчас очень активно развивается космонавтика. Многие компании и государства ставят себе цели, которые требуют активного освоения космического пространства. Но для этого нужно вывести КА на определенную орбиту и поддерживать её на протяжении всей миссии. Но в космосе очень трудно предсказать точную траекторию объекта, а особенно сложно узнать, как поведет себя тело при включении на нем двигательной установки. Это очень сильно затрудняет выполнение маневра, так как малейшее изменение скорости может сильно изменить орбиту. Поэтому составление программы выполнения маневра является комплексной задачей. Мне пришла мысль попытаться автоматизировать этот процесс, чтобы человек только подправил конечный результат.
На данный момент есть программа GMAT для планирования миссий, но в ней маневры выполняются с помощью мгновенного приращения импульса. Из-за такой особенности реальная орбита может сильно отличаться от расчётной.

![Gmat_img](https://github.com/Daniil10001/Manevr/blob/main/img/img1.jpg)
![Gmat_img_2](https://github.com/Daniil10001/Manevr/blob/main/img/img2.jpg)

Для оптимизации маневра я выбрал нейронную сеть как аппроксимацию таблицы времени запуска двигателя и включения РСУ и генетический алгоритм для оптимизации самой НС. Также был разработан способ оценки приспособленности решения и учета времени отклика блока управления спутником и активации двигателя.
![Neuron Network](https://github.com/Daniil10001/Manevr/blob/main/img/img3.jpg)

С помощью языка программирования Python разработана программа, которая с помощью модулей *pygad* и *scipy* запускает оптимизацию, в ходе которой решается система дифференциальных уравнений, чтобы определить приспособленность функции.

![enter image description here](https://latex.codecogs.com/svg.image?%5Cleft%5C%7B%5Cbegin%7Bmatrix%7D&space;%5Cfrac%7B%5Cpartial&space;v_%7Bx%7D%7D%7B%5Cpartial&space;t%7D&space;=&space;-&space;%5Ctfrac%7BG*M*x%7D%7B%7B%28%7Bx%7D%5E%7B2%7D&plus;%7By%7D%5E%7B2%7D%29%7D%5E%7B%5Cfrac%7B3%7D%7B2%7D%7D%7D&space;&plus;&space;F%28t%29*sin%5Cvarphi&space;&space;%5C%5C%5Cfrac%7B%5Cpartial&space;v_%7By%7D%7D%7B%5Cpartial&space;t%7D&space;=&space;-&space;%5Ctfrac%7BG*M*y%7D%7B%7B%28%7Bx%7D%5E%7B2%7D&plus;%7By%7D%5E%7B2%7D%29%7D%5E%7B%5Cfrac%7B3%7D%7B2%7D%7D%7D&space;&plus;&space;F%28t%29*cos%5Cvarphi&space;&space;%5C%5C%5Cfrac%7B%5Cpartial&space;x%7D%7B%5Cpartial&space;t%7D&space;=&space;v_%7Bx%7D&space;%5C%5C%5Cfrac%7B%5Cpartial&space;y%7D%7B%5Cpartial&space;t%7D&space;=&space;v_%7By%7D&space;%5C%5C%5Cfrac%7B%5Cpartial&space;%5Cvarphi&space;%7D%7B%5Cpartial&space;t%7D&space;=&space;%5Comega%28t%29%5Cend%7Bmatrix%7D%5Cright.)

Но из-за то, что алгоритм быстро попадает в локальный минимум, мы не можем добиться лучших результатов. Поэтому сейчас ведется работа над алгоритмом пред обучения, чтобы обойти локальные минимумы.

Для сбалансированного манера 
![graphic1](https://github.com/Daniil10001/Manevr/blob/main/img/img4.jpg)
Для полученного решения манера
![graphic2](https://github.com/Daniil10001/Manevr/blob/main/img/img5.jpg)
